/// Parse the output from the detection model and return a list of bounding boxes
private func parseDetectionModelOutput(from outputTensor: Tensor) -> [BoundingBox] {
    
    let outputSize = outputTensor.shape.dimensions.reduce(1, {x, y in x * y})
    let outputData = UnsafeMutableBufferPointer<Float32>.allocate(capacity: outputSize)
    defer { outputData.deallocate() }
    var _ = outputTensor.data.copyBytes(to: outputData)
    
    var detections: [BoundingBox] = []
    
    // More lenient bounds - based on your model's expected input size (256x256)
    // Allow coordinates to be outside image bounds for partially visible objects
    let maxSafeFloat: Float32 = Float32(Int.max / 1000) // Much safer conversion limit
    let minSafeFloat: Float32 = Float32(Int.min / 1000)
    
    for i in (0..<1344) {
        let conf = outputData[i + 1344 * 5] // This is always safe
        
        // Only process high-confidence detections
        guard conf > detectionConfidenceThreshold else { continue }
        
        // Get raw float values
        let xmFloat = outputData[i]
        let ymFloat = outputData[i + 1344]
        let wFloat = outputData[i + 1344 * 2]
        let hFloat = outputData[i + 1344 * 3]
        
        // Only check for finite values and extreme cases that would crash Int conversion
        guard xmFloat.isFinite && ymFloat.isFinite && wFloat.isFinite && hFloat.isFinite else {
            print("Skipping detection with non-finite values")
            continue
        }
        
        // Only filter out values that would definitely crash the Int conversion
        guard xmFloat >= minSafeFloat && xmFloat <= maxSafeFloat &&
              ymFloat >= minSafeFloat && ymFloat <= maxSafeFloat &&
              wFloat >= minSafeFloat && wFloat <= maxSafeFloat &&
              hFloat >= minSafeFloat && hFloat <= maxSafeFloat else {
            print("Skipping detection with values too large for Int conversion: x=\(xmFloat), y=\(ymFloat), w=\(wFloat), h=\(hFloat)")
            continue
        }
        
        // Now safe to convert to Int
        let xm = Int(xmFloat)
        let ym = Int(ymFloat)
        let w = Int(wFloat)
        let h = Int(hFloat)
        
        // Allow negative coordinates (partially visible objects) and large dimensions
        // Only filter out clearly invalid boxes (zero or negative dimensions)
        guard w > 0 && h > 0 else {
            print("Skipping detection with invalid dimensions: w=\(w), h=\(h)")
            continue
        }
        
        let bounding_box = BoundingBox(rect: CGRect(x: xm, y: ym, width: w, height: h), conf: conf, id: detections.count + 1)
        detections.append(bounding_box)
    }
    
    print("Parsed \(detections.count) valid detections")
    return detections
}
