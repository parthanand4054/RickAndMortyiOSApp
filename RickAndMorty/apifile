/// Helper function -- preprocess one detection
///
/// - Parameter ciImg: original image
/// - Parameter detection: bounding box detected in originalImage
/// - Parameter context: CIContext used to crop the ciImage around detection
/// - Returns: normalized BGR pixel values in form [128x128x3] from a resized and cropped image of a detection
private func preprocessOneDetection(ciImg: CIImage, detection: BoundingBox, context: CIContext) -> Data? {
    
    // get the cropped image
    guard let cropped = ciImg.crop(to: detection.rect, localizerDimensions: localizerInputShape, context: context) else { return nil }
        
    // resize the detection, keeping the aspect ratio the same.
    var constAspectRatioSize: CGSize = CGSize(width: 0, height: 0)
    if cropped.width > cropped.height {
        // Reduce the longer edge to 128
        constAspectRatioSize.width = 128
        // Resize the other edge to keep the aspect ratio
        constAspectRatioSize.height = CGFloat(Int(CGFloat((128 * cropped.height) / cropped.width)))
    }
    else {
        constAspectRatioSize.height = 128
        constAspectRatioSize.width = CGFloat(Int(CGFloat((128 * cropped.width) / cropped.height)))
    }
    
    guard let resized = cropped.resize(to: constAspectRatioSize)
        else { return nil }
        
    // Get image data
    guard let cgContext = CGContext(
        data: nil,
        width: resized.width, height: resized.height,
        bitsPerComponent: 8, bytesPerRow: resized.width * 4,
        space: CGColorSpaceCreateDeviceRGB(), bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue
    ) else {
        return nil
    }
        
    cgContext.draw(resized, in: CGRect(x: 0, y: 0, width: resized.width, height: resized.height))
    guard let imageData = cgContext.data else { return nil }
        
    var inputData = Data()
        
    // TODO: Get embedder input size from the model itself.
    let embedderHeight = Int(embedderInputShape.height)
    let embedderWidth = Int(embedderInputShape.width)
    
    let lastLowerPaddingRow = (embedderHeight - resized.height) / 2
    let firstUpperPaddingRow = (embedderHeight - resized.height) / 2 + resized.height
    
    let lastLeftPaddingColumn = (embedderWidth - resized.width) / 2
    let firstRightPaddingColumn = (embedderWidth - resized.width) / 2 + resized.width
    
    // write BGR data normalized to [0,1] to a 3x256x256 matrix
    for colorChannel in [3, 2, 1] { // Changed variable name to avoid collision
        // Separately keep track of what row we are on in the picture
        var rowInPic = 0
        for row in 0..<embedderHeight {
            
            // Separately keep track of what column we are on in the picture
            var colInPic = 0
            
            var onPaddingRow = false
            
            if row < lastLowerPaddingRow || row >= firstUpperPaddingRow { // Fixed comparison
                onPaddingRow = true
            }
            
            // Check if we're in a padding row or a real image data row
            for col in 0..<embedderWidth {
                var onPaddingColumn = false
                
                if col < lastLeftPaddingColumn || col >= firstRightPaddingColumn {
                    onPaddingColumn = true
                }
                
                // Initialize normalized color to white
                var normalizedColor = Float32(1.0)
                
                // Only change normalized color if we are not on a "padding" pixel
                if !onPaddingRow && !onPaddingColumn {
                    
                    // Bounds checking to prevent crash
                    let pixelIndex = rowInPic * cgContext.width + colInPic
                    let totalPixels = cgContext.width * cgContext.height
                    
                    if pixelIndex >= 0 && pixelIndex < totalPixels {
                        // ignore offset 0 (unused alpha)
                        let offset = 4 * pixelIndex
                        
                        // Additional bounds check for the specific byte access
                        if offset + colorChannel < cgContext.bytesPerRow * cgContext.height {
                            // get the [colorChannel] value
                            let colorValue = imageData.load(fromByteOffset: offset + colorChannel, as: UInt8.self)
                            normalizedColor = Float32(colorValue) / 255
                        }
                    }
                    
                    colInPic += 1
                }
                
                // Append normalized values to Data object
                let elementSize = MemoryLayout.size(ofValue: normalizedColor)
                var bytes = [UInt8](repeating: 0, count: elementSize)
                memcpy(&bytes, &normalizedColor, elementSize)
                inputData.append(&bytes, count: elementSize)
            }
            
            if !onPaddingRow {
                rowInPic += 1
            }
        }
    }
    return inputData
}
