//
//  EmbeddingMatcher.swift


import Foundation

class EmbeddingMatcher {
    typealias Embeddings = [String: [[Float]]]
    private var catalogue: Embeddings = [:]
    var lruCache: LRUCache = LRUCache(capacity: 50)
    private var apiService = EmbeddingsAPIService()
    
    // Embedding Matcher Settings
    private let embeddingSampleSize: Int = 2
    private let cutoffThreshold: Float = 0.10
    private let minCacheMatch: Float = 0.93
    
    /// Initialize the embedding matcher
    ///
    /// - Parameter jsonFileName: file name for JSON file which contains [product1ID: [embedding1, embedding2, ...], product2ID: [embedding1, embedding2, ...], ...]
    /// - Returns: initialized EmbeddingMatcher if the JSON file is successfully loaded and decoded
    init?(jsonFileName: String? = nil) {
        // We'll still keep the ability to load from JSON file for testing purposes
        if let jsonFileName = jsonFileName {
            do {
                if let filePath = Bundle.main.path(forResource: jsonFileName, ofType: "json") {
                    let fileUrl = URL(fileURLWithPath: filePath)
                    let json = try Data(contentsOf: fileUrl)
                    self.catalogue = try JSONDecoder().decode(Embeddings.self, from: json)
                    print("Successfully initialized the embedding matcher from JSON file")
                } else {
                    print("Failed to make filepath, initializing with empty catalogue")
                }
            } catch let error {
                print("Error initializing from JSON: \(error.localizedDescription), initializing with empty catalogue")
            }
        } else {
            print("Initializing embedding matcher with empty catalogue, will fetch embeddings from API")
        }
    }
    
    /// Match a list of embeddings to products in our catalogue
    ///
    /// - Parameter embeddings: list of Embedding data types (includes a detection ID and embedding)
    /// - Returns: list of (detectionID, prodID, similarity score) tuples
    func matchAllEmbeddings(embeddings: [Embedding]) async -> [(Int, String, Float)] {
        let processors = ProcessInfo.processInfo.activeProcessorCount

        let pooledResults: [(Int, String, Float)] = await withTaskGroup(of: [(Int, String, Float)].self) { group in
            var matches = [(Int, String, Float)]()
            
            for i in 0..<Int(processors) {
                group.addTask {
                    var localMatches = [(Int, String, Float)]()

                    let lowerBound = Float(i)/Float(processors) * Float(embeddings.count)
                    let upperBound = Float(i+1)/Float(processors) * Float(embeddings.count)

                    for index in Int(lowerBound)..<Int(upperBound) {
                        let match = self.getNearestMatch(embedding: embeddings[index].embedding)
                            
                        let res = (embeddings[index].id, match.0, match.1)
                        localMatches.append(res)
                    }
                    return localMatches
                }
            }
                
            for await value in group {
                matches.append(contentsOf: value)
            }
            return matches
        }
        
        return pooledResults
    }
    
    /// Get the nearest match of one embedding
    ///
    /// - Parameter embedding: embedding of one object
    /// - Returns: (ProdID, Similarity Score) of best match
    func getNearestMatch(embedding: [Float], seenThreshold: Float = 0.88) -> (String, Float) {
        var closestProd = ""
        var mostSim = -Float.infinity
        
        // First check our cache of recently seen products.
        if self.lruCache.count > 0 {
            for prod in self.lruCache.seen {
                // Safely unwrap the catalogue entry.
                if let prodEmbeddings = self.catalogue[prod] {
                    for prodEmbedding in prodEmbeddings {
                        let sim = abs(cosineSim(A: embedding, B: prodEmbedding))
                        if sim > mostSim {
                            mostSim = sim
                            closestProd = prod
                        }
                    }
                }
            }
        }
        
        if mostSim > minCacheMatch {
            return (closestProd, mostSim)
        }
        
        // If no good match was found in the cache, check all products in the catalogue.
        for prod in self.catalogue.keys {
            // Force-unwrapping here is acceptable if you are sure every key in the catalogue exists.
            let shuffled = self.catalogue[prod]!.shuffled()
            // We randomly sample a subset of the embeddings for efficiency.
            for i in 0..<max(1, Int(shuffled.count / embeddingSampleSize)) {
                let sim = abs(cosineSim(A: embedding, B: shuffled[i]))
                if sim > mostSim {
                    mostSim = sim
                    closestProd = prod
                } else if sim < cutoffThreshold {
                    break
                }
            }
        }
        
        // Add this check to reject poor matches
        if mostSim < 0.7 {
            print("poor match \(mostSim)")
            return ("", mostSim) // Return empty string for no match
        }
        
        return (closestProd, mostSim)
    }
    
    /// Fetch embeddings for a specific product ID from the API
    /// - Parameters:
    ///   - productID: The product ID to fetch embeddings for
    ///   - completion: Callback when the fetch completes
    func fetchEmbeddings(for productID: String, completion: @escaping (Bool) -> Void) {
        apiService.fetchEmbeddings(upc: productID) { [weak self] result in
            guard let self = self else { completion(false); return }
            
            switch result {
            case .success(let embeddings):
                // Update the local catalogue with the new embeddings
                for (id, embeddingsArray) in embeddings {
                    self.catalogue[id] = embeddingsArray
                }
                print("Successfully fetched embeddings for \(productID)")
                completion(true)
                
            case .failure(let error):
                print("Failed to fetch embeddings: \(error.localizedDescription)")
                completion(false)
            }
        }
    }
    
    func addToSeen(prodID: String){
        self.lruCache.insert(prodID)
    }
    
    /** Cosine similarity **/
    private func cosineSim(A: [Float], B: [Float]) -> Float {
        return dot(A: A, B: B) / (magnitude(A: A) * magnitude(A: B))
    }

    /** Dot Product **/
    private func dot(A: [Float], B: [Float]) -> Float {
        var x: Float = 0
        for i in 0...min(A.count, B.count)-1 {
            x += A[i] * B[i]
        }
        return x
    }

    /** Vector Magnitude **/
    private func magnitude(A: [Float]) -> Float {
        var x: Float = 0
        for elt in A {
            x += elt * elt
        }
        return sqrt(x)
    }
}
