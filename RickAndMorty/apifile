/// Parse the output from the detection model and return a list of bounding boxes
private func parseDetectionModelOutput(from outputTensor: Tensor) -> [BoundingBox] {
    
    let outputSize = outputTensor.shape.dimensions.reduce(1, {x, y in x * y})
    let outputData = UnsafeMutableBufferPointer<Float32>.allocate(capacity: outputSize)
    defer { outputData.deallocate() }
    var _ = outputTensor.data.copyBytes(to: outputData)
    
    var detections: [BoundingBox] = []
    
    // Define reasonable bounds for coordinates (based on typical image sizes)
    let maxCoordinate: Float32 = 2000.0  // Reasonable upper bound
    let minCoordinate: Float32 = -100.0  // Allow some negative values
    let maxDimension: Float32 = 1000.0   // Maximum width/height
    
    for i in (0..<1344) {
        let conf = outputData[i + 1344 * 5]
        
        // Only process high-confidence detections
        guard conf > detectionConfidenceThreshold else { continue }
        
        // Get raw float values
        let xmFloat = outputData[i]
        let ymFloat = outputData[i + 1344]
        let wFloat = outputData[i + 1344 * 2]
        let hFloat = outputData[i + 1344 * 3]
        
        // Check if values are reasonable before conversion
        guard xmFloat.isFinite && ymFloat.isFinite && wFloat.isFinite && hFloat.isFinite else {
            print("Skipping detection with non-finite values")
            continue
        }
        
        // Check if values are within reasonable bounds
        guard xmFloat >= minCoordinate && xmFloat <= maxCoordinate &&
              ymFloat >= minCoordinate && ymFloat <= maxCoordinate &&
              wFloat > 0 && wFloat <= maxDimension &&
              hFloat > 0 && hFloat <= maxDimension else {
            print("Skipping detection with unreasonable values: x=\(xmFloat), y=\(ymFloat), w=\(wFloat), h=\(hFloat)")
            continue
        }
        
        // Now safe to convert to Int
        let xm = Int(xmFloat)
        let ym = Int(ymFloat)
        let w = Int(wFloat)
        let h = Int(hFloat)
        
        let bounding_box = BoundingBox(rect: CGRect(x: xm, y: ym, width: w, height: h), conf: conf, id: detections.count + 1)
        detections.append(bounding_box)
    }
    
    print("Parsed \(detections.count) valid detections out of potential high-confidence detections")
    return detections
}
