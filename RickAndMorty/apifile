//
//  Data+Gunzip.swift
//
//  A tiny GZIP inflator that works on every iOS version
//

import Foundation
import zlib

extension Data {
    /// Full GZIP inflator using zlib (windowBits = 16 + MAX_WBITS)
    func fullGunzip() -> Data? {
        guard !isEmpty else { return self }

        var stream = z_stream()
        stream.next_in  = UnsafeMutablePointer<Bytef>(mutating:
            (self as NSData).bytes.bindMemory(to: Bytef.self, capacity: count))
        stream.avail_in = uInt(count)

        let windowBits = 16 + MAX_WBITS            // +16 = gzip header/trailer
        guard inflateInit2_(&stream,
                            Int32(windowBits),
                            ZLIB_VERSION,
                            Int32(MemoryLayout<z_stream>.size)) == Z_OK else { return nil }

        var output = Data()
        let chunk  = 16 * 1024
        var status: Int32 = Z_OK

        while status == Z_OK {
            var buffer = [UInt8](repeating: 0, count: chunk)
            buffer.withUnsafeMutableBytes { outPtr in
                stream.next_out  = outPtr.bindMemory(to: Bytef.self).baseAddress
                stream.avail_out = uInt(chunk)
                status = inflate(&stream, Z_NO_FLUSH)
                let written = chunk - Int(stream.avail_out)
                output.append(outPtr.baseAddress!.assumingMemoryBound(to: UInt8.self),
                              count: written)
            }
        }

        inflateEnd(&stream)
        return status == Z_STREAM_END ? output : nil
    }
}
