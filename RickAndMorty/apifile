//
//  EmbeddingsAPIService.swift
//

import Foundation
import zlib

class EmbeddingsAPIService {
    
    /// Fetch embeddings for a specific UPC
    /// - Parameters:
    ///   - upc: The UPC identifier for the product
    ///   - completion: Callback with the result containing embeddings or an error
    func fetchEmbeddings(upc: String, completion: @escaping (Result<[String: [[Float]]], Error>) -> Void) {
        // 1. build request
        var url = URL(string:
            "https://developer.api.us.stg.walmart.com/api-proxy/service/COMPASS/SERVICE/v4/embeddings/upc"
        )!
        url.append(queryItems: [.init(name: "upc_id", value: upc)])

        var req = URLRequest(url: url)
        req.httpMethod = "GET"
        req.setValue("c061c52a-b978-4ae9-9875-6584e58e8a74",         // consumer-id
                     forHTTPHeaderField: "wm_consumer.id")
        req.setValue("Bearer eyJraWQiOiJkOTY5MzBhYy04YjhlLT...",     // â† fresh JWT
                     forHTTPHeaderField: "Authorization")

        let session = URLSession(configuration: .default,
                                 delegate: InsecureTLSDelegate(),
                                 delegateQueue: nil)

        // 2. run
        session.dataTask(with: req) { data, _, error in
            if let error = error {
                completion(.failure(error))
                return
            }
            
            guard let data = data else {
                completion(.failure(NSError(domain: "EmbeddingsAPIService", code: 1, userInfo: [NSLocalizedDescriptionKey: "No data received"])))
                return
            }

            // 3. outer JSON
            do {
                guard
                    let outer = try JSONSerialization.jsonObject(with: data) as? [String:Any],
                    let status = outer["status"] as? String,
                    let b64 = outer["payload"] as? String,
                    let gz = Data(base64Encoded: b64),
                    let raw = gz.fullGunzip(),
                    let inner = try JSONSerialization.jsonObject(with: raw) as? [String:Any]
                else { 
                    completion(.failure(NSError(domain: "EmbeddingsAPIService", code: 2, userInfo: [NSLocalizedDescriptionKey: "Decode failed"])))
                    return
                }
                
                if status != "OK" {
                    completion(.failure(NSError(domain: "EmbeddingsAPIService", code: 3, userInfo: [NSLocalizedDescriptionKey: "API returned status: \(status)"])))
                    return
                }
                
                // 4. Process the inner content to extract embeddings
                var result = [String: [[Float]]]()
                
                for (upcKey, rawEmb) in inner {
                    var vectors = [[Float]]()
                    
                    // Handle different possible formats of embeddings
                    if let oneVec = rawEmb as? [NSNumber] {
                        vectors = [oneVec.map { $0.floatValue }]
                    } else if let arrArr = rawEmb as? [[NSNumber]] {
                        vectors = arrArr.map { $0.map { $0.floatValue } }
                    } else if let objArr = rawEmb as? [[String:Any]] {
                        for obj in objArr {
                            if let vecNS = obj["embedding"] as? [NSNumber] {
                                vectors.append(vecNS.map { $0.floatValue })
                            }
                        }
                    }
                    
                    if !vectors.isEmpty {
                        result[upcKey] = vectors
                    }
                }
                
                completion(.success(result))
                
            } catch {
                completion(.failure(error))
            }
        }.resume()
    }
}

// Helper class for handling insecure TLS for staging
private final class InsecureTLSDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ s: URLSession, didReceive c: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        if let trust = c.protectionSpace.serverTrust {
            completionHandler(.useCredential, URLCredential(trust: trust))
        } else {
            completionHandler(.performDefaultHandling, nil)
        }
    }
}

// Tiny GZIP helper
extension Data {
    func fullGunzip() -> Data? {
        guard !isEmpty else { return self }
        var stream = z_stream()
        stream.next_in  = UnsafeMutablePointer<Bytef>(mutating:
            (self as NSData).bytes.bindMemory(to: Bytef.self, capacity: count))
        stream.avail_in = uInt(count)
        guard inflateInit2_(&stream, 16 + MAX_WBITS, ZLIB_VERSION,
                            Int32(MemoryLayout<z_stream>.size)) == Z_OK else { return nil }
        var out = Data(); let chunk = 16 * 1024; var status: Int32 = Z_OK
        while status == Z_OK {
            var buf = [UInt8](repeating: 0, count: chunk)
            buf.withUnsafeMutableBytes { p in
                stream.next_out  = p.bindMemory(to: Bytef.self).baseAddress
                stream.avail_out = uInt(chunk)
                status = inflate(&stream, Z_NO_FLUSH)
                out.append(p.baseAddress!.assumingMemoryBound(to: UInt8.self),
                           count: chunk - Int(stream.avail_out))
            }
        }
        inflateEnd(&stream)
        return status == Z_STREAM_END ? out : nil
    }
}
