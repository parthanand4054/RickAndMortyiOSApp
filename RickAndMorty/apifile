//
//  ContentView.swift
//  API quick-test  (compact UPC key + array-of-arrays)
//
//  Output example:
//  {
//    "status" : "OK",
//    "errors" : [],
//    "1600036245" : [
//      [ 0.4868, -0.1773, … ],
//      [ -0.2419, -0.2227, … ]
//    ]
//  }
//

import SwiftUI
import zlib

struct ContentView: View {
    @State private var console = "Fetching…"

    var body: some View {
        ScrollView {
            Text(console)
                .font(.system(.body, design: .monospaced))
                .padding()
        }
        .onAppear { fetch(upc: "1600036245") }          // ← test UPC here
    }

    // MARK: – Networking
    private func fetch(upc: String) {

        // 1. build request -------------------------------------------------
        var url = URL(string:
            "https://developer.api.us.stg.walmart.com/api-proxy/service/COMPASS/SERVICE/v4/embeddings/upc"
        )!
        url.append(queryItems: [.init(name: "upc_id", value: upc)])

        var req = URLRequest(url: url)
        req.httpMethod = "GET"
        req.setValue("c061c52a-b978-4ae9-9875-6584e58e8a74",         // consumer-id
                     forHTTPHeaderField: "wm_consumer.id")
        req.setValue("Bearer eyJraWQiOiJkOTY5MzBhYy04YjhlLT...",     // ← fresh JWT
                     forHTTPHeaderField: "Authorization")

        let session = URLSession(configuration: .default,
                                 delegate: InsecureTLSDelegate(),
                                 delegateQueue: nil)

        // 2. run ----------------------------------------------------------
        session.dataTask(with: req) { data, _, error in
            guard error == nil, let data else { log("❌ \(error!.localizedDescription)"); return }

            // 3. outer JSON ----------------------------------------------
            guard
                let outer = try? JSONSerialization.jsonObject(with: data) as? [String:Any],
                let status  = outer["status"],
                let errors  = outer["errors"],
                let b64     = outer["payload"] as? String,
                let gz      = Data(base64Encoded: b64),
                let raw     = gz.fullGunzip(),
                let inner   = try? JSONSerialization.jsonObject(with: raw) as? [String:Any],
                let rawEmb  = inner[upc]
            else { log("❌ decode failed"); return }

            // 4. normalise to [[Float]] ----------------------------------
            var vectors = [[Float]]()

            if let oneVec = rawEmb as? [NSNumber] {                      // single flat
                vectors = [ oneVec.map { $0.floatValue } ]

            } else if let arrArr = rawEmb as? [[NSNumber]] {             // array of arrays
                vectors = arrArr.map { $0.map { $0.floatValue } }

            } else if let objArr = rawEmb as? [[String:Any]] {           // [{ id:…, embedding:[…] }, …]
                for obj in objArr {
                    if let vecNS = obj["embedding"] as? [NSNumber] {
                        vectors.append(vecNS.map { $0.floatValue })
                    }
                }
            } else {
                log("❌ unrecognised embeddings format"); return
            }

            // 5. compact JSON -------------------------------------------
            let compact: [String:Any] = [
                "status" : status,
                "errors" : errors,
                upc      : vectors
            ]
            let pretty = try? JSONSerialization.data(withJSONObject: compact, options: .prettyPrinted)
            if let pretty, let str = String(data: pretty, encoding: .utf8) {
                log(str)
            } else {
                log("❌ couldn’t pretty-print JSON")
            }

        }.resume()
    }

    private func log(_ text: String) { DispatchQueue.main.async { console = text; print(text) } }
}

// ─────────────────────────────────────────────────────────────────────────
// staging-cert helper
private final class InsecureTLSDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ s: URLSession, didReceive c: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        if let trust = c.protectionSpace.serverTrust {
            completionHandler(.useCredential, URLCredential(trust: trust))
        } else {
            completionHandler(.performDefaultHandling, nil)
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────
// tiny GZIP helper
private extension Data {
    func fullGunzip() -> Data? {
        guard !isEmpty else { return self }
        var stream = z_stream()
        stream.next_in  = UnsafeMutablePointer<Bytef>(mutating:
            (self as NSData).bytes.bindMemory(to: Bytef.self, capacity: count))
        stream.avail_in = uInt(count)
        guard inflateInit2_(&stream, 16 + MAX_WBITS, ZLIB_VERSION,
                            Int32(MemoryLayout<z_stream>.size)) == Z_OK else { return nil }
        var out = Data(); let chunk = 16 * 1024; var status: Int32 = Z_OK
        while status == Z_OK {
            var buf = [UInt8](repeating: 0, count: chunk)
            buf.withUnsafeMutableBytes { p in
                stream.next_out  = p.bindMemory(to: Bytef.self).baseAddress
                stream.avail_out = uInt(chunk)
                status = inflate(&stream, Z_NO_FLUSH)
                out.append(p.baseAddress!.assumingMemoryBound(to: UInt8.self),
                           count: chunk - Int(stream.avail_out))
            }
        }
        inflateEnd(&stream)
        return status == Z_STREAM_END ? out : nil
    }
}
