//
//  EmbeddingFetcher.swift
//
//  One-shot fetch: UPC ➜ compact JSON {status, errors, embeddings[]}
//

import Foundation
import SwiftUI
import zlib                         // for gunzip helper

// MARK: – Public entry point (use anywhere)
func fetchEmbeddingsJSON(for upc: String,
                         completion: @escaping (Result<String, Error>) -> Void) {
    Task {
        do {
            let json = try await EmbeddingFetcher().run(upc: upc)
            completion(.success(json))
        } catch {
            completion(.failure(error))
        }
    }
}

// MARK: – Private worker type
fileprivate struct EmbeddingFetcher {

    // ── static config ──────────────────────────────────────────
    private static let consumerID = "c061c52a-b978-4ae9-9875-6584e58e8a74"
    private static let bearerJWT  = """
    eyJraWQiOiJkOTY5MzBhYy04YjhlLT...   // ← paste fresh JWT here
    """

    private static let baseURL = URL(string:
        "https://developer.api.us.stg.walmart.com/api-proxy/service/COMPASS/SERVICE/v4/embeddings/upc"
    )!

    // ── main async pipeline ───────────────────────────────────
    func run(upc: String) async throws -> String {

        // 1) build request
        var url = Self.baseURL
        url.append(queryItems: [.init(name: "upc_id", value: upc)])

        var req = URLRequest(url: url)
        req.httpMethod = "GET"
        req.setValue(Self.consumerID,                   forHTTPHeaderField: "wm_consumer.id")
        req.setValue("Bearer \(Self.bearerJWT)",        forHTTPHeaderField: "Authorization")

        // 2) call
        let (data, resp) = try await URLSession(configuration: .default,
                                                delegate: InsecureTLSDelegate(),
                                                delegateQueue: nil)
                                 .data(for: req)

        guard (resp as? HTTPURLResponse)?.statusCode == 200 else {
            throw URLError(.badServerResponse)
        }

        // 3) decode outer JSON
        guard
            let outer = try? JSONSerialization.jsonObject(with: data) as? [String:Any],
            let status  = outer["status"],
            let errors  = outer["errors"],
            let payloadB64 = outer["payload"] as? String,
            let gz  = Data(base64Encoded: payloadB64),
            let raw = gz.fullGunzip(),
            let inner = try? JSONSerialization.jsonObject(with: raw) as? [String:Any],
            let vec  = inner[upc] as? [NSNumber]
        else { throw NSError(domain: "decode", code: 0) }

        // 4) build compact dict
        let compact: [String:Any] = [
            "status":   status,
            "errors":   errors,
            "embeddings": vec.map { $0.floatValue }
        ]

        // 5) pretty-print JSON for console
        let pretty = try JSONSerialization.data(withJSONObject: compact, options: .prettyPrinted)
        return String(data: pretty, encoding: .utf8)!
    }
}

// MARK: – Minimal TLS delegate for staging cert
fileprivate final class InsecureTLSDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ s: URLSession, didReceive c: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        if let trust = c.protectionSpace.serverTrust {
            completionHandler(.useCredential, URLCredential(trust: trust))
        } else {
            completionHandler(.performDefaultHandling, nil)
        }
    }
}

// MARK: – GZIP helper (unchanged from PoC)
fileprivate extension Data {
    func fullGunzip() -> Data? {
        guard !isEmpty else { return self }
        var stream = z_stream()
        stream.next_in  = UnsafeMutablePointer<Bytef>(mutating:
            (self as NSData).bytes.bindMemory(to: Bytef.self, capacity: count))
        stream.avail_in = uInt(count)

        guard inflateInit2_(&stream, 16+MAX_WBITS, ZLIB_VERSION,
                            Int32(MemoryLayout<z_stream>.size)) == Z_OK else { return nil }

        var out = Data(); let chunk = 16*1024; var status: Int32 = Z_OK
        while status == Z_OK {
            var buf = [UInt8](repeating: 0, count: chunk)
            buf.withUnsafeMutableBytes { p in
                stream.next_out = p.bindMemory(to: Bytef.self).baseAddress
                stream.avail_out = uInt(chunk)
                status = inflate(&stream, Z_NO_FLUSH)
                let written = chunk - Int(stream.avail_out)
                out.append(p.baseAddress!.assumingMemoryBound(to: UInt8.self), count: written)
            }
        }
        inflateEnd(&stream)
        return status == Z_STREAM_END ? out : nil
    }
}
